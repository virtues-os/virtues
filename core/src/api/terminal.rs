use async_trait::async_trait;
use axum::{
    extract::{
        ws::{Message, WebSocket, WebSocketUpgrade},
        State,
    },
    response::IntoResponse,
};
use russh::{client, ChannelMsg, Pty};
use std::sync::Arc;
use std::time::Duration;

use crate::server::ingest::AppState;

/// Internal SSH key path (generated by entrypoint.sh, persisted in /data volume)
const SSH_KEY_PATH: &str = "/data/ssh/internal_key";

// ---------------------------------------------------------------------------
// russh client handler — minimal, accepts localhost host keys
// ---------------------------------------------------------------------------

struct SshHandler;

#[async_trait]
impl client::Handler for SshHandler {
    type Error = russh::Error;

    async fn check_server_key(
        &mut self,
        _key: &russh::keys::PublicKey,
    ) -> Result<bool, Self::Error> {
        // Safe: connecting to localhost sshd inside the same gVisor container
        Ok(true)
    }
}

// ---------------------------------------------------------------------------
// WebSocket handler
// ---------------------------------------------------------------------------

/// Handler for the terminal WebSocket
pub async fn terminal_ws_handler(
    ws: WebSocketUpgrade,
    State(_state): State<AppState>,
) -> impl IntoResponse {
    ws.on_upgrade(handle_socket)
}

/// Handle the established WebSocket connection
async fn handle_socket(mut socket: WebSocket) {
    let is_production = std::env::var("RUST_ENV")
        .map(|v| v == "production")
        .unwrap_or(false);

    if !is_production {
        // DEV MODE: Local echo (no sshd running locally)
        dev_echo_loop(&mut socket).await;
        return;
    }

    // PRODUCTION: Bridge WebSocket <-> SSH to localhost
    if let Err(e) = ssh_bridge(&mut socket).await {
        tracing::error!("Terminal SSH bridge error: {}", e);
        let _ = socket
            .send(Message::Text(format!(
                "\r\n\x1b[31mTerminal error: {}\x1b[0m\r\n",
                e
            )))
            .await;
    }
}

// ---------------------------------------------------------------------------
// Production: SSH bridge
// ---------------------------------------------------------------------------

async fn ssh_bridge(socket: &mut WebSocket) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    // Default terminal size (frontend will send resize immediately)
    let cols: u32 = 80;
    let rows: u32 = 24;

    // 1. Load the internal SSH key
    let key = russh::keys::load_secret_key(SSH_KEY_PATH, None)?;

    // 2. Connect to localhost sshd
    let config = Arc::new(client::Config {
        inactivity_timeout: Some(Duration::from_secs(3600)), // 1 hour
        keepalive_interval: Some(Duration::from_secs(15)),
        keepalive_max: 3,
        ..<_>::default()
    });

    let mut handle = client::connect(config, ("127.0.0.1", 22u16), SshHandler).await?;

    // 3. Authenticate with internal key
    let authenticated = handle
        .authenticate_publickey("virtues", Arc::new(key))
        .await?;

    if !authenticated {
        let _ = socket
            .send(Message::Text(
                "\x1b[31mSSH authentication failed.\x1b[0m\r\n".to_string(),
            ))
            .await;
        return Ok(());
    }

    // 4. Open session channel with PTY + shell
    let mut channel = handle.channel_open_session().await?;

    channel
        .request_pty(
            false,
            "xterm-256color",
            cols,
            rows,
            0,
            0,
            &[
                (Pty::TTY_OP_ISPEED, 14400),
                (Pty::TTY_OP_OSPEED, 14400),
            ],
        )
        .await?;

    channel.request_shell(true).await?;

    // 5. Bidirectional bridge: WebSocket <-> SSH channel
    loop {
        tokio::select! {
            // WebSocket -> SSH: user input and resize events
            ws_msg = socket.recv() => {
                match ws_msg {
                    Some(Ok(Message::Text(t))) => {
                        if let Ok(cmd) = serde_json::from_str::<serde_json::Value>(&t) {
                            let msg_type = cmd.get("type").and_then(|v| v.as_str()).unwrap_or("");

                            match msg_type {
                                "input" => {
                                    if let Some(data) = cmd.get("data").and_then(|v| v.as_str()) {
                                        channel.data(&data.as_bytes()[..]).await?;
                                    }
                                }
                                "resize" => {
                                    let c = cmd.get("cols").and_then(|v| v.as_u64()).unwrap_or(80) as u32;
                                    let r = cmd.get("rows").and_then(|v| v.as_u64()).unwrap_or(24) as u32;
                                    channel.window_change(c, r, 0, 0).await?;
                                }
                                _ => {}
                            }
                        }
                    }
                    Some(Ok(Message::Close(_))) | None => {
                        break;
                    }
                    Some(Err(e)) => {
                        tracing::debug!("Terminal WebSocket error: {}", e);
                        break;
                    }
                    _ => {}
                }
            }

            // SSH -> WebSocket: shell output
            ssh_msg = channel.wait() => {
                match ssh_msg {
                    Some(ChannelMsg::Data { ref data }) => {
                        let text = String::from_utf8_lossy(data);
                        if socket.send(Message::Text(text.into_owned())).await.is_err() {
                            break;
                        }
                    }
                    Some(ChannelMsg::ExtendedData { ref data, .. }) => {
                        let text = String::from_utf8_lossy(data);
                        if socket.send(Message::Text(text.into_owned())).await.is_err() {
                            break;
                        }
                    }
                    Some(ChannelMsg::ExitStatus { exit_status }) => {
                        let _ = socket
                            .send(Message::Text(format!(
                                "\r\n\x1b[90m[process exited with code {}]\x1b[0m\r\n",
                                exit_status
                            )))
                            .await;
                        break;
                    }
                    Some(ChannelMsg::Eof) | None => {
                        break;
                    }
                    _ => {}
                }
            }
        }
    }

    // Cleanup
    let _ = channel.eof().await;
    let _ = channel.close().await;
    let _ = handle
        .disconnect(russh::Disconnect::ByApplication, "", "")
        .await;

    Ok(())
}

// ---------------------------------------------------------------------------
// Dev mode: simple echo loop for UI testing
// ---------------------------------------------------------------------------

async fn dev_echo_loop(socket: &mut WebSocket) {
    let _ = socket
        .send(Message::Text(
            "\x1b[32m✓ Connected to Local Dev Environment.\x1b[0m\r\n\
             \x1b[90m> SSH terminal is only available in production.\r\n\
             > This terminal is in echo mode for UI testing.\x1b[0m\r\n\r\n\
             virtues-dev $ "
                .to_string(),
        ))
        .await;

    while let Some(msg) = socket.recv().await {
        if let Ok(msg) = msg {
            match msg {
                Message::Text(t) => {
                    if let Ok(cmd) = serde_json::from_str::<serde_json::Value>(&t) {
                        if let Some(data) = cmd.get("data").and_then(|v| v.as_str()) {
                            if data == "\r" {
                                let _ = socket
                                    .send(Message::Text("\r\nvirtues-dev $ ".to_string()))
                                    .await;
                            } else if data == "\u{7f}" {
                                let _ = socket
                                    .send(Message::Text("\x08 \x08".to_string()))
                                    .await;
                            } else {
                                let _ = socket.send(Message::Text(data.to_string())).await;
                            }
                        }
                    }
                }
                Message::Close(_) => return,
                _ => {}
            }
        } else {
            return;
        }
    }
}
